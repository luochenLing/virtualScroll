{"version":3,"file":"virtual-scroll.mjs","sources":["../src/components/Index.vue","../src/utils/with-install.ts","../src/main.ts"],"sourcesContent":["<script setup lang=\"ts\">\r\nimport {\r\n  computed,\r\n  onActivated,\r\n  onMounted,\r\n  reactive,\r\n  ref,\r\n  watch,\r\n  nextTick,\r\n  defineProps,\r\n  PropType,\r\n  defineEmits,\r\n} from \"vue\";\r\n\r\ntype IdataSet = {\r\n  title: string;\r\n  name: string;\r\n  time: string;\r\n  imgUrl: string;\r\n  address: string;\r\n}[];\r\n\r\nconst props = defineProps({\r\n  dataSet: {\r\n    type: Array as PropType<IdataSet>,\r\n    required: true,\r\n  },\r\n  scrollBottomHandler: {\r\n    type: Function as PropType<() => void>,\r\n  },\r\n  loadOrEndDataToolTip: {\r\n    type: Object as PropType<HTMLElement | string>,\r\n    default: \"正在努力加载中...\",\r\n  },\r\n});\r\n\r\nconst emits = defineEmits([\"scrollBottomHandler\"]);\r\n\r\nconst data = reactive<{\r\n  /**\r\n   * 可放信息条数（计算出来的）\r\n   */\r\n  itemCount: number;\r\n  /**\r\n   * 开始的索引（计算出来的）\r\n   */\r\n  startIdx: number;\r\n  /**\r\n   * 当前滚动条到顶部的距离，要记录下来防止跳转后返回的时候不能回到当前位置\r\n   */\r\n  curScorllTop: number;\r\n}>({\r\n  itemCount: 0,\r\n  startIdx: 0,\r\n  curScorllTop: 0,\r\n});\r\n\r\n/**\r\n * 视口区域大小\r\n */\r\nconst scrollRef = ref();\r\n\r\n/**\r\n * 单条记录的高度,有多个，所以要取第一个\r\n */\r\nconst itemRef = ref<any>();\r\n\r\nonMounted(async () => {\r\n  window.onresize = () => {\r\n    getItemLength();\r\n  };\r\n});\r\n//路由记录到使用keepalive的时候会触发这个生命钩子\r\nonActivated(() => {\r\n  nextTick(() => {\r\n    scrollRef.value.scrollTop = data.curScorllTop;\r\n  });\r\n});\r\n\r\nwatch(\r\n  () => [props.dataSet, itemRef.value],\r\n  () => {\r\n    getItemLength();\r\n  }\r\n);\r\n\r\n/**\r\n * 区域内展示的数据集合\r\n */\r\nconst showList = computed(() => {\r\n  let sIdx = getStardIdx();\r\n  let ret = props.dataSet.slice(sIdx, endStart.value);\r\n  return ret;\r\n});\r\n\r\n/**\r\n * 结束的位置\r\n */\r\nconst endStart = computed(() => {\r\n  //当前一屏内容还要加上缓冲区一屏的内容所以要两个屏（itemCount）\r\n  let endStart = data.startIdx + data.itemCount * 2;\r\n  if (!props.dataSet[endStart]) {\r\n    endStart = props.dataSet.length - 1;\r\n  }\r\n  return endStart;\r\n});\r\n\r\n/**\r\n * 容器的边距\r\n */\r\nconst contentBlankHeight = computed(() => {\r\n  let sIdx = getStardIdx();\r\n  let itemHeight = itemRef.value ? itemRef.value[0]?.offsetHeight : 100; //默认项的高度是100PX\r\n  let bottomBlankHeight = (props.dataSet.length - endStart.value) * itemHeight;\r\n  let topBlankHeight = itemHeight * sIdx; //滚动一个就加了一个的高度做空白填充\r\n  return {\r\n    paddingTop: `${topBlankHeight}px`,\r\n    paddingBottom: `${bottomBlankHeight}px`,\r\n  };\r\n});\r\n\r\n/**\r\n * 获取单个数据的高度\r\n */\r\nconst getItemLength = () => {\r\n  let itemHeight = itemRef.value ? itemRef.value[0]?.offsetHeight : 100; //默认项的高度是100PX\r\n  data.itemCount = ~~(scrollRef.value.offsetHeight / itemHeight) + 2; //默认项的高度是100PX\r\n};\r\n\r\n/**\r\n * 滚动方法\r\n */\r\nconst handlerScroll = async () => {\r\n  let fps = 30; //一秒的帧数，一般电脑流畅的话就要30帧，有的电脑只支持15帧\r\n  let interval = 1000 / fps; //间隔多久调用滚动方法一次，按一秒算\r\n  let then = Date.now();\r\n  requestAnimationFrame(() => {\r\n    let now = Date.now();\r\n    setDataStartIdx();\r\n    //时间对比，大于间隔时间的时候才会调用方法\r\n    if (now - then >= interval) {\r\n      then = now;\r\n      //@ts-ignore\r\n      requestAnimationFrame(arguments.callee);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * 滚动的时候改变开始索引从而加载数据\r\n */\r\nconst setDataStartIdx = async () => {\r\n  data.curScorllTop = scrollRef.value.scrollTop;\r\n  let currendIdx = ~~(\r\n    scrollRef.value.scrollTop / itemRef.value[0]?.offsetHeight\r\n  );\r\n\r\n  //计算滚动到第几个的公式是滚动条到顶部的距离除以单个信息的高度\r\n  if (currendIdx === data.startIdx) {\r\n    return;\r\n  }\r\n  data.startIdx = currendIdx;\r\n  if (data.startIdx + data.itemCount > props.dataSet.length - 1) {\r\n    console.log(\"到底了\");\r\n    emits(\"scrollBottomHandler\");\r\n  }\r\n};\r\n\r\n/**\r\n * 得到缓冲区计算的startIdx\r\n */\r\nconst getStardIdx = () => {\r\n  let startIdx = 0;\r\n  if (data.startIdx <= data.itemCount) {\r\n    //一屏没滚动完的时候不传入新的截取数据的开始索引\r\n    startIdx = 0;\r\n  } else {\r\n    //滚动完一屏后开始加载下一屏，这时候从新计算开始索引要减去滚动的一屏的位置\r\n    startIdx = data.startIdx - data.itemCount;\r\n  }\r\n  return startIdx;\r\n};\r\n\r\n</script>\r\n\r\n<template>\r\n  <article\r\n    class=\"visual-scroll\"\r\n    ref=\"scrollRef\"\r\n    @scroll.passive=\"handlerScroll\"\r\n  >\r\n    <div :style=\"contentBlankHeight\">\r\n      <span class=\"item\" v-for=\"(item, idx) in showList\" ref=\"itemRef\" v-cloak>\r\n        <slot name=\"item\" :data=\"item\"></slot>\r\n      </span>\r\n      <div v-if=\"props.dataSet.length > data.itemCount\">\r\n        <slot name=\"toolTip\"></slot>\r\n      </div>\r\n    </div>\r\n  </article>\r\n</template>\r\n\r\n<style scoped lang=\"less\">\r\n[v-cloak] {\r\n  display: none !important;\r\n  color: aquamarine;\r\n}\r\n.visual-scroll {\r\n  height: 100vh;\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n  width: 100%;\r\n  .item {\r\n    border-bottom: 1px solid #454545;\r\n    padding: 10px;\r\n    font-size: 16px;\r\n    justify-content: space-between;\r\n    width: 100%;\r\n    display: flex;\r\n  }\r\n}\r\n</style>\r\n","import type { App, Plugin } from \"vue\"; // 只导入类型 而不是导入值\r\n\r\n// 类型必须导出 否则生成不了.d.ts\r\nexport type SFCWithInstall<T> = T & Plugin\r\nexport const withInstall = <T>(comp: T) => {\r\n  (comp as SFCWithInstall<T>).install = function (app: App) {\r\n    app.component((comp as any).name, comp)\r\n  }\r\n  return comp as SFCWithInstall<T>\r\n}\r\n","import VirtualScroll from \"./components/Index.vue\";\nimport { withInstall } from \"./utils/with-install\";\nconst llcVirtualScroll = withInstall(VirtualScroll);\n\nexport { llcVirtualScroll };\n"],"names":["data","reactive","scrollRef","ref","itemRef","onMounted","getItemLength","onActivated","nextTick","watch","props","showList","computed","sIdx","getStardIdx","endStart","contentBlankHeight","itemHeight","bottomBlankHeight","handlerScroll","interval","then","now","setDataStartIdx","currendIdx","emits","startIdx","withInstall","comp","app","llcVirtualScroll","VirtualScroll"],"mappings":";;;;;;;;;;;;;;;;;;iBAsCMA,IAAOC,EAaV;AAAA,MACD,WAAW;AAAA,MACX,UAAU;AAAA,MACV,cAAc;AAAA,IAAA,CACf,GAKKC,IAAYC,KAKZC,IAAUD;AAEhB,IAAAE,EAAU,YAAY;AACpB,aAAO,WAAW,MAAM;AACR,QAAAC;MAAA;AAAA,IAChB,CACD,GAEDC,EAAY,MAAM;AAChB,MAAAC,EAAS,MAAM;AACH,QAAAN,EAAA,MAAM,YAAYF,EAAK;AAAA,MAAA,CAClC;AAAA,IAAA,CACF,GAEDS;AAAA,MACE,MAAM,CAACC,EAAM,SAASN,EAAQ,KAAK;AAAA,MACnC,MAAM;AACU,QAAAE;MAChB;AAAA,IAAA;AAMI,UAAAK,IAAWC,EAAS,MAAM;AAC9B,UAAIC,IAAOC;AAEJ,aADGJ,EAAM,QAAQ,MAAMG,GAAME,EAAS,KAAK;AAAA,IAC3C,CACR,GAKKA,IAAWH,EAAS,MAAM;AAE9B,UAAIG,IAAWf,EAAK,WAAWA,EAAK,YAAY;AAC5C,aAACU,EAAM,QAAQK,OACjBA,IAAWL,EAAM,QAAQ,SAAS,IAE7BK;AAAAA,IAAA,CACR,GAKKC,IAAqBJ,EAAS,MAAM;AACxC,UAAIC,IAAOC,KACPG,IAAab,EAAQ,QAAQA,EAAQ,MAAM,IAAI,eAAe,KAC9Dc,KAAqBR,EAAM,QAAQ,SAASK,EAAS,SAASE;AAE3D,aAAA;AAAA,QACL,YAAY,GAFOA,IAAaJ;AAAA,QAGhC,eAAe,GAAGK;AAAA,MAAA;AAAA,IACpB,CACD,GAKKZ,IAAgB,MAAM;AAC1B,UAAIW,IAAab,EAAQ,QAAQA,EAAQ,MAAM,IAAI,eAAe;AAClE,MAAAJ,EAAK,YAAY,CAAC,EAAEE,EAAU,MAAM,eAAee,KAAc;AAAA,IAAA,GAM7DE,IAAgB,YAAY;AAEhC,UAAIC,IAAW,MADL,IAENC,IAAO,KAAK;AAChB,4BAAsB,MAAM;AACtB,YAAAC,IAAM,KAAK;AACC,QAAAC,KAEZD,IAAMD,KAAQD,MACTC,IAAAC,GAEP,sBAAsB,UAAU,MAAM;AAAA,MACxC,CACD;AAAA,IAAA,GAMGC,IAAkB,YAAY;AAC7B,MAAAvB,EAAA,eAAeE,EAAU,MAAM;AAChC,UAAAsB,IAAa,CAAC,EAChBtB,EAAU,MAAM,YAAYE,EAAQ,MAAM,IAAI;AAI5C,MAAAoB,MAAexB,EAAK,aAGxBA,EAAK,WAAWwB,GACZxB,EAAK,WAAWA,EAAK,YAAYU,EAAM,QAAQ,SAAS,MAC1D,QAAQ,IAAI,oBAAK,GACjBe,EAAM,qBAAqB;AAAA,IAC7B,GAMIX,IAAc,MAAM;AACxB,UAAIY,IAAW;AACX,aAAA1B,EAAK,YAAYA,EAAK,YAEb0B,IAAA,IAGAA,IAAA1B,EAAK,WAAWA,EAAK,WAE3B0B;AAAA,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iEChLIC,IAAc,CAAIC,OAC5BA,EAA2B,UAAU,SAAUC,GAAU;AACpD,EAAAA,EAAA,UAAWD,EAAa,MAAMA,CAAI;AAAA,GAEjCA,ICNHE,IAAmBH,EAAYI,CAAa;"}